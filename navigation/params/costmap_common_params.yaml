
obstacle_range: 5   # in real it's 10 m, but that reduces the complexity
raytrace_range: 6.0
max obstacle height: 2.0 #meters
footprint: [[-0.62, -0.44], [0.62, -0.44], [0.62, 0.44], [-0.62, 0.44]]
# footprint_padding: 0.05

transform_tolerance: 0.5


map_type: costmap

recovery_behaviors: [
    {name: conservative_clear, type: clear_costmap_recovery/ClearCostmapRecovery},
    {name: aggressive_clear, type: clear_costmap_recovery/ClearCostmapRecovery}
]

obstacle_layer:
    observation_sources: laser_scan_sensor #point_cloud_sensor
    laser_scan_sensor: {sensor_frame: laser, data_type: LaserScan, topic: /scan, marking: true, clearing: true, min_obstacle_height: 0.15, max_obstacle_height: 2.35}
    
static_layer:
    enabled:              true
    map_topic: /map 
    subscribe_to_updates: true
# inflation radius and cost scaling factor are the parameters that determine
# the inflation. inflation radius controls how far away the zero cost point is from the obstacle. 
#cost scaling factor is inversely proportional to the cost of a cell.
# Setting it higher will make the decay curve more steep.
inflation_layer:
    enabled:              true
    #   cost_scaling_factor:  2.0  # exponential rate at which the obstacle cost drops off (default: 10)
    inflation_radius:     0.3  # max. distance from an obstacle at which costs are incurred for planning paths.
    cost_scaling factor: 5
    # neutral cost: 66
    
# point_cloud_sensor: {sensor_frame: zed_camera_center, data_type: PointCloud2, topic: /zed/zed_node/point_cloud/cloud_registered, marking: true, clearing: false, min_obstacle_height: 0.0, max_obstacle_height: 0.15}

# voxel map configuration; z-voxels 0 are filled by bumpers and 1 by laser scan (kinect)
# map_type: voxel
# origin_z: 0.0
# z_resolution: 0.2
# z_voxels: 2
# publish_voxel_map: false